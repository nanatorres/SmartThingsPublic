/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

/**
*  Blink Camera Service Configuration Manager
*
* Copyright RBoy, redistribution of code is not allowed without permission
* Version 3.9.1
* 2016-4-2 - Debug messages to help find issues
* 2016-3-31 - Fix for ST platform state variable issue causing it lose track of last motion check resulting in previous motion events being reported as motion detection
* 2016-3-31 - Updated comment on switch interface to bring it more inline with Blink's definition
* 2016-3-30 - Fixed wrong version number reported
* 2016-3-29 - Fixed issue with  motion detection being reported when turning on camera if previous motion events were not processed
* 2016-3-29 - Improved UI layout
* 2016-3-22 - Added support to check for sync module going offline and reporting it to the user (don't send commands if sync module is offline)
* 2016-3-18 - Use the sync module to get information rather than polling each camera endpoint (Blink fixed endpoint), should improve performance significantly
* 2016-3-10 - Clarified description of options
* 2016-3-10 - Changed identifier string to reflect the ST client name and version number
* 2016-3-9 - Optimized and improved reliability of motion check timers and reduced server load
* 2016-3-8 - Fix for alternative detection of events from cameras (main sync module event broken till 3/19/16)
* 2016-3-8 - Added version information on top while configuring
* 2016-3-8 - Added support for integration with SHM
* 2016-3-7 - Added option to retry commands on failure (or turn it off)
* 2016-3-7 - Reusing auth token on the request to blink engineers to reduce server load
* 2016-3-7 - Optimize heartbeat system and schedule it on app install
* 2016-3-6 - Added heartbeat kickstart
* 2016-3-5 - Bugfix for scheduler backup kickstarter
* 2016-3-5 - Brand new scheduling system to make motion detection more reliable and resistant to the broken ST platform timer issues
* 2016-3-5 - Revamped the motion detection code to optimize calls to Blink server to reduce issues with the crappy ST platform timeout problem
* 2016-3-5 - Moved the refresh code on initialization to a referred run to avoid a timeout issue when many devices are configured
* 2016-3-4 - Fix for sending multiple commands to the server in a short period causing a conflict and command failure, queue and retry failed commands in 5 seconds
* 2016-3-4 - Added support to customize switch interface behavior to either control individual cameras or the entire system (sync module)
* 2016-3-3 - Clean up the code to stop execution additional commands if the camera is in conflict/busy to avoid throwing more errors
* 2016-3-3 - Dont' check for motion alerts if camera is disbaled
* 2016-3-2 - Bugfix for not being able to turn off intruder alerts
* 2016-3-2 - Kick start monitoring of events everytime camera is enabled just incast ST killed the timers
* 2016-3-2 - Poll period is a variable now and motion inactivity is linked to it
* 2016-3-2 - Default action is now to enable/disable camera. Motion must be enabled at global level for camera enable/disable to work
* 2016-3-1 - Added options to configure actions after a motion is detected
* 2016-3-1 - Added support for Motion Event notifications through Motion Sensor Interface
* 2016-2-29 - Added support for forcing camera sensors update and reporting last time they were updated
* 2016-2-27 - Added support for WiFi and LFR signal
* 2016-2-26 - Fixed issues with taking camera pictures and referred processing
* 2016-2-26 - Fixed battery reporting
* 2016-2-23 - Initial release
*
*/
definition(
    name: "Blink Camera Manager",
    namespace: "rboy",
    author: "RBoy",
    description: "Install, configure and manage your Blink cameras",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX2Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX3Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    singleInstance: true)

preferences {
    page(name: "mainPage")
}

def clientVersion() {
    return "3.9.1"
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Blink Camera Manager", install: true, uninstall: true) {
        // Let the user know the current status
        section("Blink Account Status") {
            paragraph "Blink Camera Manager ${clientVersion()}"
            if (blinkLogin && blinkPassword) {
                if (getAuthHeaders().TOKEN_AUTH) {
                    def cameras = getBlinkCamerasList()
                    if (cameras) {
                        cameras.each { camera ->
                            paragraph "Found Camera: $camera.name"
                        }
                    } else {
                        log.warn "No cameras found"
                        paragraph "No cameras found in account"
                    }
                } else {
                    log.error "Error getting account details"
                    paragraph "INVALID LOGIN: ERROR getting account details, check Login credentials or service is offline."
                }
            } else {
                log.warn "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
                paragraph "PLEASE ENTER BLINK ACCOUNT LOGIN DETAILS!"
            }
        }

        section("Blink Authentication") {
            input name: "blinkLogin", type: "text", title: "Login (eMail)", submitOnChange: true, required: true
            input name: "blinkPassword", type: "password", title: "Password", submitOnChange: true, required: true
        }

        section("Motion Detected Action Settings (optional)", hidden: ((sms || push || alarms || alarmSilent || lights || picture || cruisemap || resetPreset) ? false : true), hideable: true) {
            paragraph title: "Notifications", "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
            input "sms", "phone", title: "Send SMS Notification to", required: false
            input "push", "bool", title: "Send Push Notification", required: false
            paragraph " "
            paragraph title: "External Alarms", "Select the external Alarm device to activate (sound and strobe) when motion is detected on the camera. When Silent Alarm is enabled, only the strobe light is activated."
            input "alarms", "capability.alarm", title: "Alarm to turn on if motion is detected", multiple: true, required: false
            input "alarmSilent", "bool", title: "Silent Alarm", required: false
            paragraph " "
            paragraph title: "Lights", "Select the lights or switches to activate when motion is detected on the camera"
            input "lights", "capability.switch", title: "Select lights/switches to turn on if motion is detected", multiple: true, required: false, submitOnChange:true
            if (lights) {
                input "lightTimer", "number", title: "Turn off lights/switches after (minutes)", description: "Leave empty to not turn off lights/switches", required: false
            }
            paragraph " "
            paragraph title: "Pictures", "Enable this option to have SmartThings take a picture when motion is detected on the camera"
            input "picture", "bool", title: "Take picture if motion is detected", required: false
        }

        section("Smart Home Monitor (SHM) Integration") {
            paragraph "Use these options to Enable/Disable Motion Detection for ALL Cameras when SHM changes modes"
            input "armAway", "bool", title: "Enable Motion Detection on Away", required: false
            input "armStay", "bool", title: "Enable Motion Detection on Stay", required: false
            input "disarmOff", "bool", title: "Disable Motion Detection on Off", required: false
        }

        section("Switch Interface Behavior (optional)") {
            paragraph "Each camera exposes itself as a Switch to ST which allows you to control the motion detection feature through SmartApps and Routines.\nThis option determines how it will behave when a Switch On/Off request is received.\nEnabling this option will Arm/Disarm the Blink system (sync module)\nDisabling it will Enable/Disable motion detection for the individual camera"
            input "switchControlsSystem", "bool", title: "Switch Interface Arms/Disarms System instead of Camera", required: false
        }

        section("Advanced Settings (optional)") {
            input "enableRetry", "bool", title: "Retry commands on server error", defaultValue: "true", required: false
        }

        section("Change Name of App (optional)") {
            label title: "Assign a name", required: false
        }
    }
}

def installed()
{
    log.debug "Installed: $settings"
    initialize()
}

def updated()
{
    log.debug "Updated: $settings"

    unsubscribe()
    unschedule()
    initialize()
}

def uninstalled() {
    log.trace "Uninstalled called"
    getChildDevices().each {device ->
        log.info "Deleting Blink Camera Device $device.name"
        deleteChildDevice(device.deviceNetworkId)
    }
}

def initialize() {
    def cameras = []
    if (getAuthHeaders().TOKEN_AUTH) { // Check if we have valid login credentials otherwise it goes into a loop
        cameras = getBlinkCamerasList()
    } else {
        log.error "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
        sendNotification "Invalid Blink Login or Password Entered" // Let the user know
    }

    // Create a device for each new camera in the blink account
    cameras.each { camera ->
        try {
            def existingDevice = getChildDevice(camera.id)
            if(!existingDevice) {
                log.info "Creating Blink Camera Device $camera.name"
                def childDevice = addChildDevice("rboy", "RBoy Blink Camera", camera.id, null, [name: "Blink $camera.name", label: "Blink $camera.name", completedSetup: true])
            } else {
                log.trace "Blink Camera $existingDevice.name already exists"
            }

            atomicState."lastMotionCheck${camera.id}" = now() // Set the initial reference to check for motion events, use atomicState when using across child/parent interfaces since child cannot update state variables
            log.trace "Initializing last motion event checked at ${new Date(atomicState."lastMotionCheck${camera.id}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera $camera.name"
        } catch (e) {
            log.error "Error creating device: ${e}"
            sendNotification "Error creating Blink camera device"
            throw e // Don't lose the exception here
        }
    }

    // Delete devices for any cameras that are no longer in the blink account
    def delete = getChildDevices().findAll { device -> !cameras?.id.contains(device.deviceNetworkId) }
    delete.each {device ->
        log.info "Deleting Blink Camera Device $device.name as it no longer exists in the Blink account"
        try {
            deleteChildDevice(device.deviceNetworkId)
        } catch (e) {
            log.error e
            sendNotification "Device $device.displayName still in use. Remove from any SmartApps or Dashboards, then try again"
            throw e // Don't lose the exception here
        }
    }

    // Update the Switch interface behavior for the camera
    getChildDevices().each { device ->
        device.updateSwitchBehavior(switchControlsSystem)
    }

    atomicState.lastMotionMonitorCheck = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables
    atomicState.lastHeartBeat = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables

    // Subscribe to events to trigger kick start to compensate for broken ST timers
    subscribe(location, "sunrise", kickStart)
    subscribe(location, "sunset", kickStart)
    subscribe(location, "mode", kickStart)

    // SHM Integration
    subscribe(location, "alarmSystemStatus", shmHandler)

    runEvery5Minutes(kickStart) // Start the heartBeat system
    runIn(1, refreshAll) // Refresh all devices status to get switch status and do it offline to avoid timing out
}

// Integration with SHM
def shmHandler(evt) {
    log.trace "SHM Handler called with state $evt.value"
    
    if (state.lastSHMState == evt.value) {
        log.trace "No change in SHM state, nothing to do"
        return // Nothing to do here, no change
    }

    switch (evt.value) {
        case "stay":
        	if (armStay) {
                log.trace "Enabling All Cameras Motion Detection on Stay"
                getChildDevices().each { device ->
                    enableAlerts(device)
                }
            } else {
                log.trace "No action configured for Stay"
            }
            break

        case "away":
        	if (armAway) {
                log.trace "Enabling All Cameras Motion Detection on Away"
                getChildDevices().each { device ->
                    enableAlerts(device)
                }
            } else {
                log.trace "No action configured for Away"
            }
            break

        case "off":
        	if (disarmOff) {
                log.trace "Disabling All Cameras Motion Detection on Away"
                getChildDevices().each { device ->
                    disableAlerts(device)
                }
            } else {
                log.trace "No action configured for Away"
            }
            break
            
        default:
            log.error "Invalid SHM state: $evt.value"
            break
    }

    state.lastSHMState = evt.value // Save it for next time on success
}

// Start the motion check monitoring
def startMonitor(async = false) {
    log.trace "Start Monitor Called, start polling for motion events. Synchronously: $sync"

    if (!async) { // Do it right now in the current context
        checkForMotionEvents()
    } else { // Do it offline asynchronously to avoid platform timeout
        runIn (1, checkForMotionEvents) // Do it asynchronously to avoid timeout issues with the crappy platform
    }
}

// Stop the motion check monitoring
def stopMonitor(evt) {
    log.trace "Stop Monitor Called, stop polling for motion events"

    unschedule()
}

// MOTION DETECTION AND HEARTBEAT MONITORING
// To work around the stupid broken ST platform timers setup multiple level of mechanisms to poll for motion detection (i.e. heartbeat monitor for motion detection) (thanks for @copy-ninja for the idea)
def kickStart(evt) {
    log.trace "Kick start called by $evt"

    if (!evt) {
        atomicState.lastHeartBeat = now() // Save the last time we scheduled motion event checks when not called by an event (i.e. heartbeat)
    }

    def monitorStatus = false
    def networkInfo = getNetworkInfo(null)
    if (networkInfo?.armed) {
        log.trace "Global Monitor Armed"
        monitorStatus = true
    } else {
        log.trace "Global Monitor DisArmed"
        monitorStatus = false
    }

    if (monitorStatus) { // If the monitoring is active
        // Reschedule the motion detection check if didn't update for more than 1 minutes beyond the polling period
        log.trace "Last motion detection check was done " + ((now() - (atomicState.lastMotionMonitorCheck ?: 0))/(60*1000)) + " minutes ago"
        if ((((atomicState.lastMotionMonitorCheck ?: 0) + (pollPeriod() * 1000) + (1*60*1000)) < now()) && canSchedule()) {
            log.warn "Motion detection hasn't been run a long time, rescheduling it for every ${pollPeriod()/60} minutes"
            schedule("* */" + (pollPeriod()/60) + " * * * ?", startMonitor) // Schedule the monitor check
            startMonitor(true) // It died, start the checking for motion events, do it offline/deferred
        }

        if (evt) { 
            log.trace "Scheduling a backup motion detection scheduler in 11 minutes" 
            runIn((5+6)*60, backupMotionDetectionScheduler) // Schedule a backup in 11 minutes (since the heartbeat runs every 5 minutes give it some grace)
            startMonitor() // Just incase it died, start the checking for motion events, driven by an external event then do it synchronously
        }
    }
}

// Backup scheduler (incase the original is overloaded)
def backupMotionDetectionScheduler() { 
    log.trace "Backup Motion Detection Scheduler"
    startMonitor() // Do it in the current context don't defer it
}

// Check every 60 seconds for new motion events (60 is the minimum resolution that can run reliably on the platform)
private pollPeriod() {
    return 1*60 // This should be multiple of 60 for now (due to limitations of schedule in kickStart() for now
}

def checkForMotionEvents() {
    log.trace "Called check for new motion events"

    atomicState.lastMotionMonitorCheck = now() // Update the last time we checked for motion events

    // Hack for broken ST timers - Schedule the KickStart schedule check motion events
    if (((atomicState.lastHeartBeat ?: 0) + ((5+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 5 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 10 minutes, rescheduling heartbeat"
        runEvery5Minutes(kickStart) // run the motion detection scheduler every 5 minutes (heartbeat)
        atomicState.lastHeartBeat = now() // give it 5 minutes before you schedule it again
    }

    try {
        // Optimize by checking if any devices are active before reaching out to the network
        def allDevices = getChildDevices() // Get all cameras
        if (!allDevices.any { device -> ["on", "alarm"].contains(device.currentValue("enableStatus")) }) { // If the camera motion alerts is disabled don't check for motion alerts
            log.trace "All cameras are currently disabled, skipping motion check"
            return // nothing to check
        }

        def networkId = getNetworkID(null)
        if (!networkId) {
            log.error "Unable to get networkID"
            throw new RuntimeException("Unable to get networkID")  // lets try again later
        }

        def allEvents = []
        // Make this call just once, since it's per sync module and it's a very expensive operations and calling too many times can cause the shitty platform to timeout
        allEvents = getAllEventsForSyncModule(networkId, null)
        if (!allEvents) {
            log.error "Unable to get list of all events from sync module $networkId"
            throw new RuntimeException("Unable to get list of all events from sync module $networkId") // lets try again later
        }

        // Get check camera and check if we have events for them
        log.trace "Checking all cameras for motion events"
        allDevices.each {device ->
            checkCameraForMotionEvents(allEvents, networkId, device)
        }
    } catch (e) {
        log.error "Error while trying to check for camera motion events : $e"
    } // If there is a timeout execption catch it so that we can continue scheduling timers and don't let the system die due to a crappy ST platform
}
// END MOTION DETECTION AND HEARTBEAT

def motionDetected(child) {
    log.info "Motion detected in camera ${child.device.name}"

    // turn on the alarms
    log.debug "Turning on alarms $alarms, silent: $alarmSilent"
    alarmSilent ? alarms?.strobe() : alarms?.both()

    // turn on lights
    log.debug "Turning on lights $lights"
    lights?.on()
    if (lightTimer) {
        log.trace "Scheduling lights turn off after $lightTimer minutes"
        runIn(lightTimer * 60, turnOffLights)
    }

    // take picture
    if (picture) {
        log.debug "Taking a picture with camera ${child.device.name}"
        child.take()
    }

    // Send notifications
    log.debug "SMS: $sms, Push: $push"
    def message = "${child.device.name} has detected motion"
    sms ? sendText(sms, message) : ""
    push ? sendPush(message) : sendNotificationEvent(message)
}

def turnOffLights() {
    log.debug "Schedule called, turning off lights $lights"
    lights?.off()
}

private sendText(number, message) {
    if (sms) {
        def phones = sms.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}


// Blink REST Server
private serverURL() {
    return "http://prod.immedia-semi.com"
}

private getAuthHeaders(child) {
    def authToken = ""

    try {
        log.trace "Performing login and getting authentication token"
        child?.log "Performing login and getting authentication token"
        httpPostJson(
            [
                uri: serverURL(),
                path: "/login",
                body: [
                    email: blinkLogin,
                    password: blinkPassword,
                    client_specifier: "SmartThings Client | ${clientVersion()}"
                ]
            ]
        ) { ret ->
            if (ret.data?.authtoken?.authtoken) {
                authToken = ret.data.authtoken.authtoken
                //log.trace "Received authentication token: $authToken"
                //child?.log "Received authentication token: $authToken"
            } else {
                log.error "Login failed, response: $ret.data"
                child?.log "Login failed, response: $ret.data", "error"
                authToken = null
            }
        }
    } catch (e) {
        log.error "Exception during login: $e with status $e.response.status"
        child?.log "Exception during login: $e with status $e.response.status", "error"
        authToken = null
    }

    atomicState.authToken = [ TOKEN_AUTH: authToken ] // Save it for use until it expires
    log.debug "Got new AuthToken = $atomicState.authToken"
    child?.log "Got new AuthToken = $atomicState.authToken", "debug"
    return atomicState.authToken
}

// Query Blink Account
private queryBlink(path, child = null) {
    def response = null
    try {
        log.trace "Querying Blink: $path"
        child?.log "Querying Blink: $path"
        //log.warn "Saved Auth Token: $atomicState.authToken" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken", "warn" // DEBUG
        httpGet([
            uri: serverURL(),
            path: path,
            headers: atomicState.authToken ?: getAuthHeaders(child)
        ]) { ret ->
            /*log.trace "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            child?.log "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            if (ret.status == 200) {
                //log.trace "RESPONSE>" + ret.headers.'Content-Type'
                child?.log "RESPONSE>" + ret.headers.'Content-Type'
                if(ret.headers.'Content-Type'.contains("image/jpeg")) { // If we have a picture store it directly
                    //log.trace "Got JPEG IMAGE"
                    child?.log "Got JPEG IMAGE"
                }
            }*/

            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                response = ret.data
            } else {
                log.error "No response to query: $ret.data"
                child?.log "No response to query: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while querying: $e with status $e.response.status"
        child?.log "Exception while querying: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) { // Check if the token has expired
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                getAuthHeaders(child)
                return queryBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

// Send Command to Blink Account
private configureBlink(path, child = null) {
    def response = null
    try {
        log.trace "Configuring Blink: $path"
        child?.log "Configuring Blink: $path"
        //log.warn "Saved Auth Token: $atomicState.authToken" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken", "warn" // DEBUG
        httpPostJson([
            uri: serverURL(),
            path: path,
            headers: atomicState.authToken ?: getAuthHeaders(child)
        ]) { ret ->
            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                if (ret.data.message) { // Is there a error/warning message from the Blink server
                    log.warn "Blink server response to configuration request: $ret.data.message"
                    child?.log "Blink server response to configuration request: $ret.data.message", "warn"
                }
                response = ret.data
            } else {
                log.error "No response to configuration request: $ret.data"
                child?.log "No response to configuration request: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while configuring: $e with status $e.response.status"
        child?.log "Exception while configuring: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) { // Check if the token has expired
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                getAuthHeaders(child)
                return configureBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

// Check if the command has been successfully completed
private getCommandStatus(networkId, commandId, child) {
    child?.log "Getting state of command: $commandId"

    if (!commandId) {
        child?.log "Not querying command status, invalid command id: $commandId", "warn"
        return false
    }

    def completed = false
    def info = queryBlink("/network/$networkId/command/$commandId", child)
    //child?.log info
    try {
        if (info.status_msg == "Command succeeded") {
            completed = true
        }
        child?.log "Command result: $info.status_msg"
    } catch (e) {
        child?.log "Unable to get command status: $e", "error"
        completed = false
    }

    return completed
}

// Get the first sync module network ID
private getNetworkID(child) {
    child?.log "Getting first Sync Module network ID"

    def networkId = null
    try {
        def info = queryBlink("/networks", child)
        networkId = info.networks[0].id
        child?.log "First sync module NetworkID: $networkId"
    } catch (e) {
        child?.log "Unable to get network id: $e", "error"
    }

    return networkId
}

// Check if the sync module is online and if so return sync module network ID
private isSyncModuleOnlineGetID(child) {
    child?.log "Getting first Sync Module network ID"

    def networkId = null
    try {
        def info = queryBlink("/networks", child)
        if (info.networks[0].sync_module_error) {
	        child?.log "First SYNC MODULE IS OFFLINE!", "warn"
            
            // Let the device handler know so it can update the tiles
            def events = []
            events << [name:"monitorStatus", value: "offline", displayed: true] // Show it on the logs
            child.generateEvent(events) // Update the device status
        } else {
            networkId = info.networks[0].id
            child?.log "First sync module NetworkID: $networkId"
        }
    } catch (e) {
        child?.log "Unable to get network id: $e", "error"
    }

    return networkId
}

// Get the homescreen devices and information
private getBlinkHomescreenDevices(child) {
    child.log "Getting Homescreen devices"

    def info = queryBlink("/homescreen", child)

    child.log "Found devices ${info?.devices}"
    
    return info?.devices
}

// Return map with camera 'name' and 'id'
private getBlinkCamerasList(child) {
    log.trace "Getting Cameras List"
    child?.log "Getting Cameras List"

    def cameras = []
    def info = queryBlink("/homescreen", child)
    info?.devices.each { device ->
        if (device.device_type == "camera") {
            log.trace "Found Camera $device.name with Id $device.device_id"
            child?.log "Found Camera $device.name with Id $device.device_id"
            cameras << [name: device.name, id: device.device_id as String] // Save just the camera name and id
        }
    }

    //log.trace cameras
    //child?.log cameras
    return cameras
}

// Get all cameras information
private getAllCamerasDetails(networkId, child) {
    child?.log "Getting All Cameras Details"

    def cameras = queryBlink("/network/$networkId/cameras", child)
    //child?.log cameras

    if (!cameras?.devicestatus) {
        child?.log "Error: Blink returned:$cameras", "error"
    }
    
    return cameras?.devicestatus
}

// Get specific camera information
private getCameraDetails(networkId, cameraId, child) {
    child?.log "Getting Camera $cameraId Details"

    def camera = queryBlink("/network/$networkId/camera/$cameraId", child)
    //child?.log camera.camera_status.inspect()

    if (!camera?.camera_status) {
        child?.log "Error: Blink returned:$camera", "error"
    }
    
    return camera?.camera_status
}

// Get specific camera signals information
private getCameraSignalDetails(networkId, cameraId, child) {
    child?.log "Getting Camera $cameraId Signal Details"

    def signal = queryBlink("/network/$networkId/camera/$cameraId/signals", child)
    //child?.log signal.inspect()

    return signal
}

// Get details of all videos taken from the camera currently on the cloud
private getCameraVideoDetails(networkId, cameraId, child) {
    child?.log "Getting All Videos Details for Camera ID $cameraId"

    def videos = queryBlink("/network/$networkId/camera/$cameraId/videos/unwatched", child)

    if (!videos?.video) {
        child?.log "Error: Blink returned:$videos", "error"
    }
    
    return videos?.video
}

// Get the first sync module network details
private getNetworkInfo(child) {
    child?.log "Getting first Sync module Network Info"

    def networkInfo = null
    def info = queryBlink("/networks", child)
    networkInfo = info?.networks[0]

    //child?.log "NETWORK INFO>" + networkInfo
    return networkInfo
}

// Get all the events for a sync module and all it's connected cameras
private getAllEventsForSyncModule(networkId, child) {
    child?.log "Getting All Events for Sync Module $networkId"
    log.trace "Getting All Events for Sync Module $networkId"

    // NOTE: This is a very heavy time consuming call
    //def events = queryBlink("/events", child) // Returns the last 200 events from the camera
    def events = queryBlink("/events/network/$networkId", child) // Returns the last 100 events from the camera
    //child?.log "All Events retrieved:\n${events.event.inspect()}"
    //log.trace "All Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        child?.log "Error: Blink returned:$events", "error"
        log.error "Error: Blink returned:$events"
    }
    
    return events?.event
}

// Get all the events for a camera
private getAllEventsForCamera(networkId, cameraId, child) {
    child?.log "Getting All Events for camera $cameraId"
    log.trace "Getting All Events for camera $cameraId"

    // NOTE: This is a very heavy time consuming call
    def events = queryBlink("/events/network/$networkId/camera/$cameraId", child) // Returns the last 100 events from the camera
    //child?.log "All Camera Events retrieved:\n${events.event.inspect()}"
    //log.trace "All Camera Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        child?.log "Error: Blink returned:$events", "error"
        log.error "Error: Blink returned:$events"
    }
    
    return events?.event
}


// UPDATE STATUS METHODS
// Get and update Image of camera
def Boolean updateCameraImage(child) {
    child?.log "Getting Camera Image for ${child?.device.name}"

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def camera = getCameraDetails(networkId, cameraId, child)
    if (!camera) {
        child?.log "Unable to get camera details", "error"
        return false
    }

    def imageURL = camera.thumbnail
    child?.log "Got camera $cameraId -> Image $imageURL", "debug"

    //Now retrieve the image
    def image = queryBlink(imageURL + ".jpg", child)
    //child?.log image.inspect()

    // Now save the image from the device context
    child.saveImage(image)

    return true // all done
}

// Get and update all sensor parameters of camera (Wifi, Signal, Temperature, Battery)
def Boolean updateCameraSensorStatus(child) {
    child?.log "Getting Camera Sensor Status for ${child?.device.name}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def camera = getCameraDetails(networkId, cameraId, child) // For battery and temperature
    if (!camera) {
        child?.log "Unable to get camera details", "error"
        return false
    }

    def signal = getCameraSignalDetails(networkId, cameraId, child) // For standardized signal levels
    if (!signal) {
        child?.log "Unable to get camera signal details", "error"
        return false
    }

    // Get the camera Battery status
    def battery = camera.battery_level as Float
    child?.log "Got camera $camera.camera_id -> raw battery level $battery"
    battery = (battery / 1.70).round() // TODO: Confirm max battery level is 170
    child?.log "Camera $camera.camera_id -> Battery $battery%", "debug"
    events << [name:"battery", value:battery]

    // Get the camera temperature status
    def temperature = camera.temperature
    child?.log "Got camera $camera.camera_id -> Temperature $temperature", "debug"
    events << [name:"temperature", value:temperature]

    // Get the Camera WiFi signal status
    def wifi = signal.wifi
    child?.log "Got camera $camera.camera_id -> WiFi strength $wifi", "debug"
    events << [name:"wifi", value:wifi]

    // Get the Camera LFR signal status
    def lfr = signal.lfr
    child?.log "Got camera $camera.camera_id -> LFR strength $lfr", "debug"
    events << [name:"lfr", value:lfr]

    // Get last time the sensor data was updated
    def lastUpdate = camera.updated_at
    child?.log "Got camera $camera.camera_id -> Last sensor update $lastUpdate"
    def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", lastUpdate)
    child?.log "Last sensor update ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}", "debug"
    def strUpdate = dateTime.format("EEE MMM dd", location.timeZone) + "\n " + dateTime.format("HH:mm z", location.timeZone)
    events << [name:"lastUpdate", value:strUpdate]    

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update Motion Alerts status of Camera
def Boolean updateCameraMotionAlertsStatus(child) {
    child?.log "Getting Camera Motion Alerts Status for ${child?.device.name}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasDetails(networkId, child) // For camera names and alert status
    if (!allCameras) {
        child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.camera_id == (cameraId as Long)}?.enabled
    child?.log "Got camera ${child?.device.name} -> Motion Alerts enabled status $enabled", "debug"
    if (enabled) {
        if (child.device.currentValue("motion") == "active") { // If we are currently in an alarm active state
            child?.log "Active Motion Sensor Alert in progress", "debug"
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name: "alarm", value: "both"]
                events << [name: "switch", value: "on"]
            }
            events << [name: "enableStatus", value: "alarm"]

        } else {
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name:"alarm", value:"both"]
                events << [name:"switch", value:"on"]
            }
            events << [name:"enableStatus", value:"on"]
        }
    } else {
        if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
            events << [name:"alarm", value:"off"]
            events << [name:"switch", value:"off"]
        }
        events << [name:"enableStatus", value:"off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update status of Monitoring (Global level)
def Boolean updateMonitorStatus(child) {
    child?.log "Getting Global Monitor Update Status request from ${child?.device.name}"

    def monitorStatus
    def alarmSwitch
    def networkInfo = getNetworkInfo(child)
    if (networkInfo.sync_module_error) {
        child?.log "Global Monitor SYNC MODULE OFFLINE", "warn"
        monitorStatus = "offline"
        alarmSwitch = "off"
    } else if (networkInfo?.armed) {
        child?.log "Global Monitor Armed", "debug"
        monitorStatus = "on"
        alarmSwitch = "on"
    } else {
        child?.log "Global Monitor DisArmed", "debug"
        monitorStatus = "off"
        alarmSwitch = "off"
    }

    // Monitoring is controlled at a global level for all cameras so update all devices
    getChildDevices().each {device ->
        def events = []
        if (switchControlsSystem) { // If the switch controls the system instead of the camera
            events << [name:"alarm", value: alarmSwitch]
            events << [name:"switch", value: alarmSwitch]
        }
        events << [name:"monitorStatus", value: monitorStatus]
        device.generateEvent(events) // Update the device status
    }

    return true
}

// Disable the motion event
def turnOffMotionEvent(child) {
    child?.log "Turning off Camera ${child?.device.name} motion events"
    log.trace "Turning off Camera ${child?.device.name} motion events"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasDetails(networkId, child) // For camera names and alert status
    if (!allCameras) {
        child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.camera_id == (cameraId as Long)}?.enabled
    child?.log "Got camera ${child?.device.name} -> Motion Alerts enabled status $enabled", "debug"

    if (enabled) { // If the alerts are active then switch is on and alarm is both
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.name} motion stopped"]
        events << [name: "enableStatus", value: "on"]
    } else { // otherwise all off
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.name} motion stopped"]
        events << [name: "enableStatus", value: "off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true
}

// Check for any motion events since the last poll
def checkCameraForMotionEvents(allEvents, networkId, child) {
    child?.log "Checking Camera ${child?.device.name} for new motion events"
    log.trace "Checking Camera ${child?.device.name} for new motion events"

    if (child.device.currentValue("enableStatus") == "off") { // If the camera motion alerts is disabled don't check for motion alerts
        child?.log "Skipping checking Camera ${child?.device.name} for new motion events as Camera Motion Alerts is currently disabled"
        log.trace "Skipping checking Camera ${child?.device.name} for new motion events as Camera Motion Alerts is currently disabled"
        return true // no motion alerts here
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        log.error "Unable to get camera ID"
        return false
    }

    def events = []

    if (!allEvents) { // Incase we were sent with no events (e.g. sync module list broken), lets get the camera events ourselves
        allEvents = getAllEventsForCamera(networkId, cameraId, child)
        if (!allEvents) {
            child?.log "Unable to get list of all events from camera $cameraId", "error"
            log.error "Unable to get list of all events from camera $cameraId"
        }
    }

    // Filter the motion events for a specific camera given all the events from a sync module
    def motionEvents = allEvents?.findAll { event -> (event.type == "motion") && (event.camera_id == (cameraId as Long)) } // THIS IS IT -> type=motion, created_at=XXX, id=XXX, camera_name=XXX
    //child?.log "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    //child?.log "First Motion Event retrieved for Camera $cameraId:\n${motionEvents?.first().inspect()}"
    //child?.log "Last Motion Event retrieved for Camera $cameraId:\n${motionEvents?.last().inspect()}"
    //log.trace "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    if (!motionEvents) {
        child?.log "No motion events found for camera ${child?.device.name}"
        log.trace "No motion events found for camera ${child?.device.name}"
        return true
    }

    // Now check to see if there are any new events since the last time we checked
    child?.log "Found ${motionEvents.size()} motion events for camera ${child?.device.name}"
    log.trace "Found ${motionEvents.size()} motion events for camera ${child?.device.name}"
    for (motionEvent in motionEvents) {
        def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", motionEvent.created_at)
        //child?.log "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
        //log.trace "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

        //child?.log "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        //log.trace "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"

        if (dateTime > (new Date(atomicState."lastMotionCheck${cameraId}"))) { // Check if this in a new event (since the last time we checked)
            child?.log "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", "debug"
            log.debug "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            events << [name: "motion", value: "active", descriptionText: "${child?.device.name} detected a motion event"]
            events << [name: "enableStatus", value: "alarm"]
            child.deferredLoopbackQueue(pollPeriod() * 2, "turnOffMotionEvent", true) // Disable the motion sensor event in 2 x poll period (give it time to process multiple events if there are since we are checking every 60 seconds) (overwrite any existing requests)
            motionDetected(child)
            break // Process only one motion event to avoid multiple reports / conflicts (the camera can generate multiple events in succession)
        }
    }

    // Register all the events with the camera
    events ? child.generateEvent(events) : "" // Update the device status

    atomicState."lastMotionCheck${cameraId}" = now() // Update the last time we checked for new motion events
    //child?.log "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
    //log.trace "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"

    return true // all done
}

// Check if monitor is enabled and if not then enable it
private Boolean checkAndEnableMonitorStatus(child)
{
    // Before you can change motion alerts for a camera, global monitoring must be enabled or Blink will reject the command
    if (child.device.currentValue("monitorStatus") == "off") { // If we are currently in an alarm active state
        child?.log "Global monitoring off, enabling global monitoring before changing camera motion alerts status"
        return monitorOn(child)
    } else {
        return true
    }
}


// PARENT CHILD INTERFACES
// Take a picture with the camera
def takePicture(child) {
    child?.log "Take picture with camera called by ${child?.device.name}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/thumbnail", child)
    if (ret != null) {
        child?.log "Successfully sent Take Picture Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            child?.log "Waiting 10 seconds for camera to update Blink servers before getting picture"
            child.deferredLoopbackQueue(10, "updateCameraImage") // If was successful then give it time to complete
        } else {
            child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraImage") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Take Picture Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "takePicture") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Enable Camera Motion Alerts
def enableAlerts(child) {
    child?.log "Enable Camera Motion Alerts called by ${child?.device.name}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.name}"
    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.name}"

    def ret = configureBlink("/network/$networkId/camera/$cameraId/enable", child)
    if (ret != null) {
        child?.log "Successfully sent Enable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        child?.log "Failed to send Enable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "enableAlerts") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Disable Camera Motion Alerts
def disableAlerts(child) {
    child?.log "Disable Camera Motion Alerts called by ${child?.device.name}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/disable", child)
    if (ret != null) {
        child?.log "Successfully sent Disable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Disable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "disableAlerts") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Turn on Monitoring (Globally)
def monitorOn(child) {
    child?.log "Monitor On called by ${child?.device.name}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.name}"
    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.name}"

    def ret = configureBlink("/network/$networkId/arm", child)
    if (ret != null) {
        child?.log "Successfully sent Monitor Arm, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new monitor status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        child?.log "Failed to send Monitor Arm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOn") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Turn Monitoring off (global level)
def monitorOff(child) {
    child?.log "Monitor Off called by ${child?.device.name}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/disarm", child)
    if (ret != null) {
        child?.log "Successfully sent Monitor Disarm, command Id: $ret.id"
        sent = true

        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Stop monitoring for any motion events
        stopMonitor()
    } else if (enableRetry) {
        child?.log "Failed to send Monitor Disarm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOff") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Force camera to wake up and refresh it's sensor parameters
def forceCameraSensorUpdate(child) {
    child?.log "Forcing camera ${child?.device.name} to wake up and update sensor data"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/status", child)
    if (ret != null) {
        child?.log "Successfully sent Camera Refresh Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            child?.log "Waiting 10 seconds for camera to update Blink servers before getting status update"
            child.deferredLoopbackQueue(10, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        } else {
            child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Camera Refresh Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "forceCameraSensorUpdate") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Refresh all camera parameters
def refresh(child) {
    child?.log "Refresh called by ${child.device.name}"

    //child?.log "Logging in again and getting new authentication token"
    //getAuthHeaders(child) // For sanity if the user is forcing a refresh, should we do this???

    def status = updateMonitorStatus(child)
    child?.log "Refresh MonitorStatus: $status"

    status = updateCameraMotionAlertsStatus(child)
    child?.log "Refresh CameraMotionAlertsStatus: $status"

    status = updateCameraSensorStatus(child)
    child?.log "Refresh CameraSensorStatus: $status"

    status = updateCameraImage(child)
    child?.log "Refresh GetImage: $status"

    kickStart() // Kick start the timer if it's dead

    return true // we completed it successfully
}

// Refresh all cameras all parameters
def refreshAll() {
    getChildDevices().each { device ->
        device?.log "RefreshAll called"
        refresh(device)
    }
}
