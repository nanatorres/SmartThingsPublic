/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
/*
 * Modified by RBoy, SmartThings Schlage Z-Wave lock base code as of 2015-9-19
 * Changes Copyright RBoy, redistribution of any changes or modified code is not allowed without permission
 * Version 2.3.1
 *
 * Change Log
 * 2015-11-29 - Tweaked the timeout for the relock notification for non motorized deadbolts to 3 seconds
 * 2015-11-29 - Added fix for non motorized deadbolt locks like FE599 not reporting locked after user unlocks the door using a code and it relocks automatically
 * 2015-11-21 - Readded support for attribute "invalidCode" when a user enters an invalid code too many times
 * 2015-11-20 - Corrected text from Auto unlock to Auto lock
 * 2015-11-2 - Added support to set Alarm and Sensivity levels directly from a SmartApp using setAlarm ("off", "alert", "tamper", "forced")and setSensitivity ("highest", "high", "medium", "low", "lowest") commands
 * 2015-9-29 - Added support for Schlage BE369
 * 2015-9-26 - Updated layout and colors
 * 2015-9-23 - Updated colors and layout
 * 2015-9-19 - Added support for MultiAttribute Tiles
 * 2015-7-22 - Updated base code to sync with SmartThings (removed status "invalidCode" and use "tamper" instead)
 * 2015-7-15 - Added support for BE468
 * 2015-7-15 - Improved Jammed status support
 * 2015-6-5 - Added support to get battery level on manual refresh
 * 2015-6-5 - Added support for BE469 and FE599 Schlage locks
 * 2015-2-13 - Added support for auto lock and vacation mode
 * 2015-1-20 - Added support for configuring alarm mode and alarm sensitivity
 * 2015-1-20 - Added support for motion sensor capability for alarm event
 * 2015-1-20 - Added support for door jammed status using capability "invalidCode"
 *
 */
  
 /**
 *  Z-Wave Lock
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */
 
metadata {
	// Automatically generated. Make future change here.
	definition (name: "Schlage Z-Wave Lock With Alarms", namespace: "rboy", author: "RBoy") {
		capability "Actuator"
		capability "Lock"
		capability "Polling"
		capability "Refresh"
		capability "Sensor"
		capability "Lock Codes"
		capability "Battery"
        capability "Motion Sensor"
        
        attribute "alarm", "string"
        attribute "sensitive", "string"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "lockStatus", "string"
        attribute "invalidCode", "string"

		command "unlockwtimeout"
        command "alarmToggle"
        command "setAlarm", ["string"]
        command "sensitiveToggle"
        command "setSensitivity", ["string"]
        command "enableCodeunlock"
        command "disableCodeunlock"
        command "enableAutolock"
        command "disableAutolock"

		fingerprint deviceId: "0x4003", inClusters: "0x98"
		fingerprint deviceId: "0x4004", inClusters: "0x98"
	}

	simulator {
		status "locked": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		status "unlocked": "command: 9881, payload: 00 62 03 00 00 00 FE FE"

		reply "9881006201FF,delay 4200,9881006202": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		reply "988100620100,delay 4200,9881006202": "command: 9881, payload: 00 62 03 00 00 00 FE FE"
	}

	tiles(scale: 2) {
		multiAttributeTile(name:"toggle", type: "generic", width: 6, height: 4){
			tileAttribute ("device.lock", key: "PRIMARY_CONTROL") {
                attributeState "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#79b821", nextState:"unlocking"
                attributeState "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ea9900", nextState:"locking"
                attributeState "unknown", label:"jammed", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#ff3333", nextState:"locking"
                attributeState "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#79b821"
                attributeState "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
			}
			tileAttribute ("device.lockStatus", key: "SECONDARY_CONTROL") {
				attributeState "lockStatus", label:'${currentValue}'
            }
		}
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'lock', action:"lock.lock", icon:"st.locks.lock.locked", nextState:"locking"
		}
		standardTile("unlock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'unlock', action:"lock.unlock", icon:"st.locks.lock.unlocked", nextState:"unlocking"
		}
		standardTile("alarm", "device.alarm", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unknown", action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
			state "off", label:'Alarm Off', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
			state "alert", label:'Alert Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "tamper", label:'Tamper Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "forced", label:'Forced Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "workingoff", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-off", backgroundColor:"#ffffff"
			state "workingon", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
		}
		standardTile("sensitive", "device.sensitive", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "working", label:"...", icon:"st.Health & Wellness.health6", backgroundColor:"#ffffff"
			state "highest", label:'Highest Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "high", label:'High Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "medium", label:'Medium Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "low", label:'Low Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "lowest", label:'Lowest Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
		}
		valueTile("battery", "device.battery", inactiveLabel: false, width: 2, height: 2) {
			state "battery", label:'Battery\n${currentValue}%', unit:"", backgroundColors:[
                [value: 20, color: "#ff0000"],
                [value: 35, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
		}
		standardTile("refresh", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}
		standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unknown", action:"lock.disablevacation", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
			state "enabled", label:'Code Entry On', action:"disableCodeunlock", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
			state "disabled", label:'Code Off', action:"enableCodeunlock", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#fd5050", nextState:"working"
			state "working", label:"...", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#79b8ff"
		}
		standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unknown", action:"lock.disableautolock", icon:"st.contact.contact.closed", backgroundColor:"#ffffff", nextState:"working"
			state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#79b821", nextState:"working"
			state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
			state "working", label:"...", icon:"st.contact.contact.closed", backgroundColor:"#79b8ff"
		}

		main "toggle"
		details(["toggle", "lock", "unlock", "codeunlock", "alarm", "sensitive", "autolock", "battery", "refresh"])
	}
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*

def parse(String description) {
	def result = null
	if (description.startsWith("Err")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, displayed:false)
		} else {
			result = createEvent(
				descriptionText: "This lock failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
				eventType: "ALERT",
				name: "secureInclusion",
				value: "failed",
				displayed: true,
			)
		}
	} else {
		def cmd = zwave.parse(description, [ 0x98: 1, 0x72: 2, 0x85: 2, 0x86: 1 ])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}

    def lockStatusS = "Alarm ${device.currentState('alarm')?.value}/${device.currentState('sensitive')?.value} | Battery ${device.currentState('battery')?.value}%"
    sendEvent("name": "lockStatus", "value": lockStatusS, displayed: false, isStateChange: true)
    log.trace lockStatusS
    
	log.debug "\"$description\" parsed to ${result.inspect()}"
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x62: 1, 0x71: 2, 0x80: 1, 0x85: 2, 0x63: 1, 0x98: 1, 0x86: 1])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful")
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	log.debug "Security command classes: $state.sec"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Lock is securely included")
}

def zwaveEvent(DoorLockOperationReport cmd) {
    log.debug "DoorLockOperationReport $cmd"
	def result = []
	def map = [ name: "lock" ]
	if (cmd.doorLockMode == 0xFF) {
		map.value = "locked"
	} else if (cmd.doorLockMode >= 0x40) {
		map.value = "unknown"
	} else if (cmd.doorLockMode & 1) {
		map.value = "unlocked with timeout"
	} else {
		map.value = "unlocked"
		if (state.assoc != zwaveHubNodeId) {
			log.debug "setting association"
			result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
			result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
			result << response(secure(zwave.associationV1.associationGet(groupingIdentifier:1)))
		}
	}
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	log.debug "AlarmReport $cmd"
	def result = []
	def map = null
	if (cmd.zwaveAlarmType == 6) {
		if (1 <= cmd.zwaveAlarmEvent && cmd.zwaveAlarmEvent < 10) {
			map = [ name: "lock", value: (cmd.zwaveAlarmEvent & 1) ? "locked" : "unlocked" ]
		}
		switch(cmd.zwaveAlarmEvent) {
			case 1:
				map.descriptionText = "$device.displayName was manually locked"
				break
			case 2:
				map.descriptionText = "$device.displayName was manually unlocked"
				break
			case 5:
				if (cmd.eventParameter) {
					map.descriptionText = "$device.displayName was locked with code ${cmd.eventParameter.first()}"
					map.data = [ usedCode: cmd.eventParameter[0] ]
				}
				break
			case 6:
				if (cmd.eventParameter) {
					map.descriptionText = "$device.displayName was unlocked with code ${cmd.eventParameter.first()}"
					map.data = [ usedCode: cmd.eventParameter[0] ]
				}
				break
			case 9:
				map.descriptionText = "$device.displayName was autolocked"
				break
			case 7:
			case 8:
			case 0xA:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName was not locked fully" ]
				break
			case 0xB:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName is jammed" ]
				break
			case 0xC:
				map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
				allCodesDeleted()
				break
			case 0xD:
				if (cmd.eventParameter) {
					map = [ name: "codeReport", value: cmd.eventParameter[0], data: [ code: "" ], isStateChange: true ]
					map.descriptionText = "$device.displayName code ${map.value} was deleted"
					map.isStateChange = (state["code$map.value"] != "")
					state["code$map.value"] = ""
				} else {
					map = [ name: "codeChanged", descriptionText: "$device.displayName: user code deleted", isStateChange: true ]
				}
				break
			case 0xE:
				map = [ name: "codeChanged", value: cmd.alarmLevel,  descriptionText: "$device.displayName: user code added", isStateChange: true ]
				if (cmd.eventParameter) {
					map.value = cmd.eventParameter[0]
					result << response(requestCode(cmd.eventParameter[0]))
				}
				break
			case 0xF:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: user code not added, duplicate", isStateChange: true ]
				break
			case 0x10:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: keypad temporarily disabled", displayed: true ]
				break
			case 0x11:
				map = [ descriptionText: "$device.displayName: keypad is busy" ]
				break
			case 0x12:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: program code changed", isStateChange: true ]
				break
			case 0x13:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: code entry attempt limit exceeded", displayed: true ]
				break
			default:
				map = map ?: [ descriptionText: "$device.displayName: alarm event $cmd.zwaveAlarmEvent", displayed: false ]
				break
		}
	} else if (cmd.zwaveAlarmType == 7) {
		// Door tamper alarm has been set off ZWAVE_ALARM_TYPE_BURGLAR
        map = [ name: "motion", value: "active",  descriptionText: "$device.displayName: Door tampering activity detected", displayed: true ]
		def runTime = new Date(now() + (60 * 1000))
		runOnce(runTime, deactivateMotion) // Minimum resolution is 60 seconds
        sendEvent(map)
        
		map = [ name: "tamper", value: "detected", displayed: true ]
		switch (cmd.zwaveAlarmEvent) {
			case 0:
				map.value = "clear"
				map.descriptionText = "$device.displayName: tamper alert cleared"
				break
			case 1:
			case 2:
				map.descriptionText = "$device.displayName: intrusion attempt detected"
				break
			case 3:
				map.descriptionText = "$device.displayName: covering removed"
				break
			case 4:
				map.descriptionText = "$device.displayName: invalid code"
				break
			default:
				map.descriptionText = "$device.displayName: tamper alarm $cmd.zwaveAlarmEvent"
				break
		}
	} else switch(cmd.alarmType) {
		case 21:  // Manually locked
		case 18:  // Locked with keypad
		case 24:  // Locked by command (Kwikset 914)
		case 27:  // Autolocked
			map = [ name: "lock", value: "locked" ]
			break
		case 16:  // Note: for levers this means it's unlocked, for non-motorized deadbolt, it's just unsecured and might not get unlocked
        	// Note: Schlage FE599 non motorized deadbolt sends 16 and motorized deadbolts like BE469 send 19. However with non motorized deadbolts it only unsecures the handles and not unlocks, so we need to send a lock event after a few seconds
        	log.trace "Non motorized bolt, resetting unlocked to locked notification in 3 seconds"
            runIn(3, reLocked) // The bolt resecures after 3 seconds, send the locked event notification
		case 19:
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel) {
				map.descriptionText = "$device.displayName was unlocked with code $cmd.alarmLevel"
				map.data = [ usedCode: cmd.alarmLevel ]
			}
			break
		case 22:
		case 25:  // Kwikset 914 unlocked by command
			map = [ name: "lock", value: "unlocked" ]
			break
		case 9:
		case 17:
		case 23:
		case 26:
			map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName bolt is jammed" ]
			break
		case 13:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel was added", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 32:
			map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
			allCodesDeleted()
            break
		case 33:
			map = [ name: "codeReport", value: cmd.alarmLevel, data: [ code: "" ], isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.alarmLevel was deleted"
			map.isStateChange = (state["code$cmd.alarmLevel"] != "")
			state["code$cmd.alarmLevel"] = ""
			break
		case 112:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel changed", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 130:  // Yale YRD batteries replaced
			map = [ descriptionText: "$device.displayName batteries replaced", isStateChange: true ]
			break
		case 131:
			map = [ /*name: "codeChanged", value: cmd.alarmLevel,*/ descriptionText: "$device.displayName code $cmd.alarmLevel is duplicate", isStateChange: false ]
			break
		case 161:
			if (cmd.alarmLevel == 2) {
				map = [ descriptionText: "$device.displayName front escutcheon removed", isStateChange: true ]
			} else {
				map = [ descriptionText: "$device.displayName detected failed user code attempt", isStateChange: true ]
			}
			break
		case 167:
			if (!state.lastbatt || (new Date().time) - state.lastbatt > 12*60*60*1000) {
				map = [ descriptionText: "$device.displayName: battery low", isStateChange: true ]
				result << response(secure(zwave.batteryV1.batteryGet()))
			} else {
				map = [ name: "battery", value: device.currentValue("battery"), descriptionText: "$device.displayName: battery low", displayed: true ]
			}
			break
		case 168:
			map = [ name: "battery", value: 1, descriptionText: "$device.displayName: battery level critical", displayed: true ]
			break
		case 169:
			map = [ name: "battery", value: 0, descriptionText: "$device.displayName: battery too low to operate lock", isStateChange: true ]
			break
		default:
			map = [ displayed: false, descriptionText: "$device.displayName: alarm event $cmd.alarmType level $cmd.alarmLevel" ]
			break
	}
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(UserCodeReport cmd) {
	def result = []
	def name = "code$cmd.userIdentifier"
	def code = cmd.code
	def map = [:]
	if (cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_OCCUPIED ||
		(cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_STATUS_NOT_AVAILABLE && cmd.user && code != "**********"))
	{
		if (code == "**********") {  // Schlage locks send us this instead of the real code
			state.blankcodes = true
			code = state["set$name"] ?: decrypt(state[name]) ?: code
			state.remove("set$name".toString())
		}
		if (!code && cmd.userIdStatus == 1) {  // Schlage touchscreen sends blank code to notify of a changed code
			map = [ name: "codeChanged", value: cmd.userIdentifier, displayed: true, isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier " + (state[name] ? "changed" : "was added")
			code = state["set$name"] ?: decrypt(state[name]) ?: "****"
			state.remove("set$name".toString())
		} else {
			map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: code ] ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier is set"
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = (code != decrypt(state[name]))
		}
		result << createEvent(map)
	} else {
		map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: "" ] ]
		if (state.blankcodes && state["reset$name"]) {  // we deleted this code so we can tell that our new code gets set
			map.descriptionText = "$device.displayName code $cmd.userIdentifier was reset"
			map.displayed = map.isStateChange = false
			result << createEvent(map)
			state["set$name"] = state["reset$name"]
			result << response(setCode(cmd.userIdentifier, state["reset$name"]))
			state.remove("reset$name".toString())
		} else {
			if (state[name]) {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier was deleted"
			} else {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier is not set"
			}
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = state[name] as Boolean
			result << createEvent(map)
		}
		code = ""
	}
	state[name] = code ? encrypt(code) : code

	if (cmd.userIdentifier == state.requestCode) {  // reloadCodes() was called, keep requesting the codes in order
		if (state.requestCode + 1 > state.codes || state.requestCode >= 30) {
			state.remove("requestCode")  // done
		} else {
			state.requestCode = state.requestCode + 1  // get next
			result << response(requestCode(state.requestCode))
		}
	}
	if (cmd.userIdentifier == state.pollCode) {
		if (state.pollCode + 1 > state.codes || state.pollCode >= 30) {
			state.remove("pollCode")  // done
		} else {
			state.pollCode = state.pollCode + 1
		}
	}
	log.debug "code report parsed to ${result.inspect()}"
	result
}

def zwaveEvent(UsersNumberReport cmd) {
	def result = []
	state.codes = cmd.supportedUsers
	if (state.requestCode && state.requestCode <= cmd.supportedUsers) {
		result << response(requestCode(state.requestCode))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		log.debug "$device.displayName is associated to $zwaveHubNodeId"
		result << createEvent(descriptionText: "$device.displayName is associated")
		state.assoc = zwaveHubNodeId
		if (cmd.groupingIdentifier == 2) {
			result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		}
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "$device.displayName requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd) {
	// The old Schlage locks use group 1 for basic control - we don't want that, so unsubscribe from group 1
	def result = [ createEvent(name: "lock", value: cmd.value ? "unlocked" : "locked") ]
	result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
	if (state.assoc != zwaveHubNodeId) {
		result << response(zwave.associationV1.associationGet(groupingIdentifier:2))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "$device.displayName has a low battery"
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbatt = new Date().time
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.debug "ManufacturerSpecificReport $cmd"
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (state.MSR == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	def msg = cmd.status == 0 ? "try again later" :
	          cmd.status == 1 ? "try again in $cmd.waitTime seconds" :
	          cmd.status == 2 ? "request queued" : "sorry"
	createEvent(displayed: true, descriptionText: "$device.displayName is busy, $msg")
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	createEvent(displayed: true, descriptionText: "$device.displayName rejected the last request")
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	createEvent(displayed: false, descriptionText: "$device.displayName: $cmd")
}

def lockAndCheck(doorLockMode) {
	secureSequence([
		zwave.doorLockV1.doorLockOperationSet(doorLockMode: doorLockMode),
		zwave.doorLockV1.doorLockOperationGet()
	], 4200)
}

def lock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_SECURED)
}

def unlock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED)
}

def unlockwtimeout() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED_WITH_TIMEOUT)
}

def refresh() {
	log.debug "Device MSR is $state.MSR"
	def cmds = []
	if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
		log.debug "Getting Device MSR"
    	cmds << response(zwave.manufacturerSpecificV2.manufacturerSpecificGet())
	    cmds << "delay 5000"
    }
  	cmds << secure(zwave.doorLockV1.doorLockOperationGet())
    cmds << "delay 5000"
    cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 7))
    cmds << "delay 5000"
    cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 4))
    cmds << "delay 5000"
	cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 15))
	cmds << "delay 5000"
    cmds << getSensitiveLevel()
	cmds << "delay 5000"
    cmds << secure(zwave.batteryV1.batteryGet())
	if (state.assoc == zwaveHubNodeId) {
		log.debug "$device.displayName is associated to ${state.assoc}"
	} else if (!state.associationQuery) {
		log.debug "checking association"
		cmds << "delay 4200"
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()  // old Schlage locks use group 2 and don't secure the Association CC
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = new Date().time
	} else if (new Date().time - state.associationQuery.toLong() > 9000) {
		log.debug "setting association"
		cmds << "delay 6000"
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = new Date().time
	}
    if(cmds) cmds << "delay 5000"
	log.debug "refresh sending ${cmds.inspect()}"
	cmds
}

def poll() {
	def cmds = []
	if (state.assoc != zwaveHubNodeId && secondsPast(state.associationQuery, 19 * 60)) {
		log.debug "setting association"
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << "delay 6000"
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		cmds << "delay 6000"
		state.associationQuery = new Date().time
	} else {
		// Only check lock state if it changed recently or we haven't had an update in an hour
		log.debug "Device MSR is $state.MSR"
        if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
            log.debug "Getting Device MSR"
            cmds << response(zwave.manufacturerSpecificV2.manufacturerSpecificGet())
            cmds << "delay 5000"
        }
		def latest = device.currentState("lock")?.date?.time
		if (!latest || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
			cmds << secure(zwave.doorLockV1.doorLockOperationGet())
            cmds << "delay 5000"
            cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 7))
            cmds << "delay 5000"
            cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 4))
            cmds << "delay 5000"
            cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: 15))
            cmds << "delay 5000"
            cmds << getSensitiveLevel()
			state.lastPoll = (new Date()).time
		} else if (!state.MSR) {
			cmds << zwave.manufacturerSpecificV1.manufacturerSpecificGet().format()
		} else if (!state.fw) {
			cmds << zwave.versionV1.versionGet().format()
		} else if (!state.codes) {
			state.pollCode = 1
			cmds << secure(zwave.userCodeV1.usersNumberGet())
		} else if (state.pollCode && state.pollCode <= state.codes) {
			cmds << requestCode(state.pollCode)
		} else if (!state.lastbatt || (new Date().time) - state.lastbatt > 53*60*60*1000) {
			cmds << secure(zwave.batteryV1.batteryGet())
		} else if (!state.enc) {
			encryptCodes()
			state.enc = 1
		}
	    if(cmds) cmds << "delay 6000"
	}
	log.debug "poll is sending ${cmds.inspect()}, state: ${state.inspect()}"
	device.activity()  // workaround to keep polling from being shut off
	cmds ?: null
}

private def encryptCodes() {
	def keys = new ArrayList(state.keySet().findAll { it.startsWith("code") })
	keys.each { key ->
		def match = (key =~ /^code(\d+)$/)
		if (match) try {
			def keynum = match[0][1].toInteger()
			if (keynum > 30 && !state[key]) {
				state.remove(key)
			} else if (state[key] && !state[key].startsWith("~")) {
				log.debug "encrypting $key: ${state[key].inspect()}"
				state[key] = encrypt(state[key])
			}
		} catch (java.lang.NumberFormatException e) { }
	}
}

def requestCode(codeNumber) {
	secure(zwave.userCodeV1.userCodeGet(userIdentifier: codeNumber))
}

def reloadAllCodes() {
	def cmds = []
	if (!state.codes) {
		state.requestCode = 1
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else {
		if(!state.requestCode) state.requestCode = 1
		cmds << requestCode(codeNumber)
	}
	cmds
}

def setCode(codeNumber, code) {
	def strcode = code
	log.debug "setting code $codeNumber to $code"
	if (code instanceof String) {
		code = code.toList().findResults { if(it > ' ' && it != ',' && it != '-') it.toCharacter() as Short }
	} else {
		strcode = code.collect{ it as Character }.join()
	}
	if (state.blankcodes) {
		// Can't just set, we won't be able to tell if it was successful
		if (state["code$codeNumber"] != "") {
			if (state["setcode$codeNumber"] != strcode) {
				state["resetcode$codeNumber"] = strcode
				return deleteCode(codeNumber)
			}
		} else {
			state["setcode$codeNumber"] = strcode
		}
	}
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:1, user:code),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def deleteCode(codeNumber) {
	log.debug "deleting code $codeNumber"
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:0),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def updateCodes(codeSettings) {
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)
	def set_cmds = []
	def get_cmds = []
	codeSettings.each { name, updated ->
		def current = decrypt(state[name])
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			log.debug "$name was $current, set to $updated"
			if (updated?.size() >= 4 && updated != current) {
				def cmds = setCode(n, updated)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if ((current && updated == "") || updated == "0") {
				def cmds = deleteCode(n)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if (updated && updated.size() < 4) {
				// Entered code was too short
				codeSettings["code$n"] = current
			}
		} else log.warn("unexpected entry $name: $updated")
	}
	if (set_cmds) {
		return response(delayBetween(set_cmds, 2200) + ["delay 2200"] + delayBetween(get_cmds, 4200))
	}
}

def getCode(codeNumber) {
	decrypt(state["code$codeNumber"])
}

def getAllCodes() {
	state.findAll { it.key.startsWith 'code' }.collectEntries {
		[it.key, (it.value instanceof String && it.value.startsWith("~")) ? decrypt(it.value) : it.value]
	}
}

private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

private secureSequence(commands, delay=4200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (new Date().time - timestamp) > (seconds * 1000)
}

private allCodesDeleted() {
	if (state.codes instanceof Integer) {
		(1..state.codes).each { n ->
			if (state["code$n"]) {
				result << createEvent(name: "codeReport", value: n, data: [ code: "" ], descriptionText: "code $n was deleted",
					displayed: false, isStateChange: true)
			}
			state["code$n"] = ""
		}
	}
}

// CUSTOM STUFF

def enableCodeunlock() {
    log.debug "Enabling code unlocking" 
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
    	case "003B-6349-5044":
        	log.debug "Found Schlage BE468"
            break
            
    	case "003B-634B-504C":
        	log.debug "Found Schlage FE599"
            break
            
        case "003B-634B-5044":
            log.debug "Found Schlage BE369"
                        
        default:
        	log.debug "Unsupported device with MSR $state.MSR, CodeUnLock feature not available"
            return
    }
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: 4, configurationValue: [0]),
		zwave.configurationV2.configurationGet(parameterNumber: 4)
	], 5000)
}	

def disableCodeunlock() {
    log.debug "Disabling code unlocking"
    def lockDisableCode = []
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            lockDisableCode = [255]
            break
            
    	case "003B-6349-5044":
        	log.debug "Found Schlage BE468"
            lockDisableCode = [255]
            break

		case "003B-634B-504C":
        	log.debug "Found Schlage FE599"
            lockDisableCode = [1]
            break
                        
		case "003B-634B-5044":
        	log.debug "Found Schlage BE369"
            lockDisableCode = [255]
            break
                        
        default:
        	log.debug "Unsupported device with MSR $state.MSR, CodeUnLock feature not available"
            return
    }
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: 4, configurationValue: lockDisableCode),
		zwave.configurationV2.configurationGet(parameterNumber: 4)
	], 5000)
}	

def enableAutolock() {
    log.debug "Enabling auto lock" 
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
    	case "003B-6349-5044":
        	log.debug "Found Schlage BE468"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, AutoLock feature not available"
            return
    }
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: 15, configurationValue: [255]),
		zwave.configurationV2.configurationGet(parameterNumber: 15)
	], 5000)
}	

def disableAutolock() {
    log.debug "Disabling auto lock"
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
    	case "003B-6349-5044":
        	log.debug "Found Schlage BE468"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, AutoLock feature not available"
            return
    }
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: 15, configurationValue: [0]),
		zwave.configurationV2.configurationGet(parameterNumber: 15)
	], 5000)
}	

def deactivateMotion() {
	log.debug "$device.displayName: Resetting door tampering activity sensor" 
	def map = [ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ]
    sendEvent(map)
}

def reLocked() {
	log.debug "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", displayed: true ]
    sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) {
	log.debug "ConfigurationReport $cmd"
	def result = []
    def map = null
    switch (cmd.parameterNumber) {
    	case 0x03: // Beeper
        	map = [name: "beeper", descriptionText: "Beeper", displayed: true, isStateChange: false]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x04: // Vacation (unlock using code)
        	map = [name: "codeunlock", descriptionText: "Unlock using code", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "enabled"
                    break
                    
                case 0x1:
                	if (state.MSR == "003B-634B-504C") // For Schlage FE599
                		map.value = "disabled"
                    else
	                	map.value = "unknown"
                    break
                    
                case 0xff:
                	if (state.MSR == "003B-6341-5044") // For Schlage BE469
                		map.value = "disabled"
                	else if (state.MSR == "003B-6349-5044") // For Schlage BE468
                		map.value = "disabled"
                	else if (state.MSR == "003B-634B-5044") // For Schlage BE369
                		map.value = "disabled"
                    else
	                	map.value = "unknown"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x07: // Lock specific alarm mode
        	map = [name: "alarm", descriptionText: "Alarm Mode", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "off"
                    break
                    
                case 0x1:
                	map.value = "alert"
                    break
                    
                case 0x2:
                	map.value = "tamper"
                    break
                    
                case 0x3:
                	map.value = "forced"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
            case 0x08:
            case 0x09:
        	case 0x0A: // Lock specific alarm sensitivity level
        	map = [name: "sensitive", descriptionText: "Alarm Sensitivity Level", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0x1:
            		map.value = "highest"
                    break
                    
                case 0x2:
                	map.value = "high"
                    break
                    
                case 0x3:
                	map.value = "medium"
                    break
                    
                case 0x4:
                	map.value = "low"
                    break
                    
                case 0x5:
                	map.value = "lowest"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x0F: // Auto lock
        	map = [name: "autolock", descriptionText: "Auto lock", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }

	result ? [createEvent(map), *result] : createEvent(map)
}

def modes() {
	["off", "alert", "tamper", "forced"]
}

def getModeMap() {
	[
        "off": 0,
        "alert": 1,
        "tamper": 2,
        "forced": 3
	]
}

def setAlarm(String newMode)
{
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
            return
    }

    if (!modes().contains(newMode)) {
        log.error "Request to set unknown Alarm mode $newMode"
        return
    }

	log.debug "SetAlarm setting Alarm mode to $newMode -> ${[modeMap[newMode]]}"
    secureSequence([
        zwave.configurationV2.configurationSet(parameterNumber: 7, configurationValue: [modeMap[newMode]]),
        zwave.configurationV2.configurationGet(parameterNumber: 7)
    ], 5000)
}

def alarmToggle() {
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm feature not available"
            return
    }

	def currentMode = device.currentState("alarm")?.value
	log.debug "AlarmToggle Current Alarm mode is $currentMode"
	def modeOrder = modes()
	def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
	def nextMode = next(currentMode)
    log.debug "AlarmToggle Setting Alarm mode to $nextMode -> ${modeMap[nextMode]}"
    secureSequence([
        zwave.configurationV2.configurationSet(parameterNumber: 7, configurationValue: [modeMap[nextMode]]),
        zwave.configurationV2.configurationGet(parameterNumber: 7)
    ], 5000)
}

def sensitives() {
	["highest", "high", "medium", "low", "lowest"]
}

def getSensitiveMap() {
	[
        "highest": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "lowest" : 5
	]
}

def setSensitivity(String newMode)
{
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
            return
    }

    if (!sensitives().contains(newMode)) {
        log.error "Request to set unknown Alarm sensitivity $newMode"
        return
    }

	def currentMode = device.currentState("alarm")?.value
    int currentModeValue = modeMap[currentMode]
	log.debug "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	log.warn "Not setting Alarm Sensitivity as Alarm is turned off"
    	return
    }

	log.debug "Set Sensitivity setting Alarm Sensitivity to $newMode -> ${[sensitiveMap[newMode]]}"
    secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: (7 + currentModeValue), configurationValue: [sensitiveMap[newMode]]),
		zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue))
    ], 5000)
}

def sensitiveToggle() {
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm feature not available"
            return
    }

	def currentMode = device.currentState("alarm")?.value
    int currentModeValue = modeMap[currentMode]
	log.debug "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	return
    }
	def currentSensitive = device.currentState("sensitive")?.value
	log.debug "SensitiveToggle Current Alarm sensitivity is $currentSensitive"
	def SensitiveOrder = sensitives()
	def next = { SensitiveOrder[SensitiveOrder.indexOf(it) + 1] ?: SensitiveOrder[0] }
	def nextSensitive = next(currentSensitive)
    log.debug "Setting Alarm sensitivity to $nextSensitive -> ${sensitiveMap[nextSensitive]}" 
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: (7 + currentModeValue), configurationValue: [sensitiveMap[nextSensitive]]),
		zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue))
	], 5000)
}

def getSensitiveLevel() {
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm feature not available"
            return
    }
    
	def currentMode = device.currentState("alarm")?.value
	getSensitiveLevel(currentMode)
}

def getSensitiveLevel(currentMode) {
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044":
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm feature not available"
            return
    }

	int currentModeValue = modeMap[currentMode]
	log.debug "GetSensitiveLevel Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	return
    }
    
	secure(zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue)))
}
